cluster = require('cluster')
async = require('async')
_ = require('lodash')
cmd = require('commander')
ZMS = require '../src'
host = "0.0.0.0"
port = 5101
Router = require '../src/router'
console.log host, port
fork = (ID) ->
  if !cmd['nofork'] and ID
    return cluster.fork()
  setImmediate ->
    processID = ID or cluster.worker.processID or cluster.worker.id

    done = ->
      d2 = new Date
      hmany = d2.getTime() - d1.getTime()
      console.log hmany + " milliseconds for #{tp} requests. " + (tp / (hmany / 1000)).toFixed(2) + ' requests/sec.'
      console.log "Milliseconds per request: " + (hmany/tp)
      client.stop()
      setTimeout (->
        cluster.worker.kill() if cluster.worker
        return
      ), 1000
      return

    send = ->
      prcnt = 0
      sn++
      console.log 'C/' + processID + ': WAVE=' + sn
      k = 0

      while k < cmd.p
        client.request('echo', chunk)
        .on 'data', ()->
          return
        .on 'end', ->
          rcnt++
          prcnt++
          if prcnt == cmd.p and sn < cmd.s
            send()
            return
          if rcnt < tp
            return
          done()
          return
        k++
      return

    if processID <= cmd.bn
      broker = new (require("../src/backends/zmq/broker"))(url: "tcp://#{host}:#{port}")
      broker.on 'error', (err) ->
        console.log 'broker', err
        return
      broker.start ->
        console.log 'BROKER ' + processID
      return
    else if processID <= cmd.bn + cmd.bn * cmd.wn
      b = processID % cmd.bn + 1
      # router = new Router
      #   url : "tcp://#{host}:#{port}"
      #   path: ""
      # router.route "echo",(req, res, next)->
      #   setImmediate ->
      #     return res.end req
      # router.start()
      worker = new (require("../src/backends/zmq/worker"))(url: "tcp://0.0.0.0:5101", socketConcurrency: 1000, path: 'echo')
      worker.on 'error', (err) ->
        console.log 'worker', err
        return
      worker.on 'request', (inp, res) ->
        setImmediate ->
          res.end inp
          return
      worker.start()
      return
    else
      b = processID % cmd.bn + 1
      client = new (ZMS.Client)("tcp://#{host}:#{port}")
      sn = 0
      tp = cmd.p * cmd.s
      console.log 'CLIENT (' + tp + ' reqs/' + cmd.s + ' waves) (BROKER ' + b + ')'
      client.on('connect', ->
        console.log 'connected'
        return
      ).on('disconnect', ->
        console.log 'disconnected'
        return
      ).on 'error', (err) ->
        console.log err.stack
        return
      # client.start()
      d1 = undefined
      rcnt = 0
      setTimeout (->
        d1 = new Date
        send()
        return
      ), 2000
    return
  return

cmd.option('--bn <val>', 'Num of Brokers', 1)
.option('--wn <val>', 'Num of Workers (for each Broker)', 1)
.option('--cn <val>', 'Num of Clients (for each Broker)', 1)
.option('--pn <val>', 'Num of Parallel Requests (for each Client)', 5000)
.option('--p <val>', 'Num of messages (for each Client)', 50000)
.option('--m <val>', 'Use memory cache (1=enabled|0=disabled) (default=0)', 0)
.option('--s <val>', 'Num of waves (default=1)', 1)
.option('--e <val>', 'Num of waves (default=tcp://127.0.0.1:7777)', 'tcp://127.0.0.1:777')
.option '-N, --nofork', 'Don\'t use fork'
cmd.on '--help', ->
  console.log 'Examples:'
  console.log '\nnode ' + cmd.name() + ' --bn 2 --wn 2 --cn 2 --p 50000'
  return
cmd.parse process.argv
_.each [
  'bn'
  'wn'
  'cn'
  'p'
  'm'
  's'
], (k) ->
  cmd[k] = +cmd[k]
  return
chunk = 'foo'
if cluster.isMaster
  # cmd.nofork = true
  console.log 'RUNNING CONF'
  console.log '\n', [
    cmd.bn + ' brokers'
    cmd.wn + ' workers'
    cmd.cn + ' clients'
    'cache ' + (if cmd.m then 'on' else 'off')
    cmd.p + ' requests'
  ].join(', ')
  i = 0
  while i < cmd.bn + cmd.bn * cmd.wn + cmd.bn * cmd.cn
    fork i + 1
    i++
  kills = 0
  cluster.on 'exit', (worker, code, signal) ->
    kills++
    if kills == cmd.cn * cmd.bn
      process.exit 0
    return
else
  fork()

# ---
# generated by js2coffee 2.1.0
